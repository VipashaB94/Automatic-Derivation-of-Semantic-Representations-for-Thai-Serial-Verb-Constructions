;;; Grammar of Thai
;;; created at:
;;;     Mon Feb 02 04:33:38 UTC 2009
;;; based on Matrix customization system version of:
;;;     Mon Feb  2 01:32:50 UTC 2009
 
 
;;;--------------------------------------------------------------------------
;;; Features
;;;--------------------------------------------------------------------------

;;; Verb features for SVCs
verb :+
[ SVC bool,AUX bool,NEG bool, TYPE type, SVTYPE svtype].

type := avm.

type :+
[ MDDP mddp,
  STATIVE bool,
  INTENTION bool ].

;mddp (motion, direction, deictic, posture)
mddp := *top*.
not-deictic := mddp.
not-posture := mddp.
not-direction := mddp.
not-motion := mddp.
not-none := mddp.
motion-or-posture := mddp.
motion-or-direction := mddp.

motion := not-deictic & not-posture & not-direction & not-none & motion-or-posture &
	  motion-or-direction.
direction := not-deictic & not-posture & not-motion & not-none & motion-or-direction.
posture := not-deictic & not-direction & not-motion & not-none & motion-or-posture.
deictic := not-posture & not-direction & not-motion & not-none.
none := not-deictic & not-posture & not-direction & not-motion.

;SVTYPE
svtype := *top*.
;dir-deic, directional, resultative, deic-purpose, open-purpose, simultaneous, sequential

not-dir-deic := svtype.
not-directional := svtype.
not-resultative := svtype.
not-deic-purpose := svtype.
not-open-purpose := svtype.
not-simultaneous := svtype.
not-sequential := svtype.
not-interact := svtype.
open-purpose-or-sequential := svtype.
dir-deic-or-simul := svtype.
deic-purp-vp2 := svtype.

dir-deic := not-directional & not-resultative & not-deic-purpose & not-open-purpose &
	    not-simultaneous & not-sequential & not-interact & dir-deic-or-simul.
directional := not-dir-deic & not-resultative & not-deic-purpose & not-open-purpose &
	       not-simultaneous & not-sequential & not-interact & deic-purp-vp2.
resultative := not-dir-deic & not-directional & not-deic-purpose & not-open-purpose &
	       not-simultaneous & not-sequential & not-interact.
deic-purpose := not-dir-deic & not-directional & not-resultative & not-open-purpose &
		not-simultaneous & not-sequential & not-interact.
open-purpose := not-dir-deic & not-directional & not-resultative & not-deic-purpose &
		not-simultaneous & not-sequential & not-interact & open-purpose-or-sequential
		& deic-purp-vp2.
simultaneous := not-dir-deic & not-directional & not-resultative & not-deic-purpose &
		not-open-purpose & not-sequential & not-interact & dir-deic-or-simul &
		deic-purp-vp2.
sequential := not-dir-deic & not-directional & not-resultative & not-deic-purpose &
	      not-open-purpose & not-simultaneous & not-interact & open-purpose-or-sequential
	      & deic-purp-vp2.
interact := not-dir-deic & not-directional & not-resultative & not-deic-purpose &
	    not-open-purpose & not-simultaneous & not-sequential.

;svtype := avm.
;svtype :+
;[ MOT-DIRECTIONAL bool,
;  DIR-DIRECTIONAL bool,
;  RESULTATIVE bool,
;  DEIC-PURPOSE bool,
;  OPEN-PURPOSE bool,
;  POSTURE-SV bool,
;  SEQUENTIAL bool ].

;;; 02-14-2009 gcs added Thai numeric classifier head value
numcl := +cd.
 
;;; 02-14-2009 gcs added LEFTCOMP
 
head :+
    [ FORM form,PRD bool,LEFTCOMP bool,CLASSIF string ].
       
;;; Person
 
person := *top*.
1 := person.
2 := person.
3 := person.
 
;;; Number
 
number := *top*.
sg := number.
pl := number.
 
;;; Gender
 
gender := *top*.
masc-or-fem := gender.
masc := masc-or-fem.
fem := masc-or-fem.
neut := gender.
 
;;; Person-Number-Gender
 
png :+ [ PERS person,
         NUM number,
         GEND gender ].
 
;;; Form
;;; 2009-02-21 gcs
;;; mv-form - main verb
;;; pre-fin - pre-finite stage, has combined with pre-aux
;;; finite - finite stage, has combined with (pre- and) post aux
 
form := *top*.
sealed := form.
any-form := form.
post-aux := any-form.
mv-or-pre-aux := any-form.
mv-form := mv-or-pre-aux.
pre-aux := mv-or-pre-aux.
 
;;; Aspect
 
aspect :+ [ SOON bool,
            PROGRESS bool,
            GET bool,
            EVER bool,
            ALREADY bool,
            CONTIN bool,
            SEMIPERFV bool,
            PERF bool,
            PERFV bool ].
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Lexical types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
;;;--------------------------------------------------------------------------
;;; Nouns
;;;--------------------------------------------------------------------------
 
noun-lex := basic-noun-lex & basic-one-arg & no-hcons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < #spr &
                                 [ LOCAL.CAT.HEAD det ] >,
                           COMPS < >,
                           SUBJ < >,
                           SPEC < > ],
    ARG-ST < #spr > ].
 
;;;------
;;; Nouns
 
common-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS 3 ].
 
; Nouns which cannot take specifiers mark their SPR requirement
; as OPT +.  Making the non-head daughter OPT - in this rule
; keeps such nouns out.
 
no-spr-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ].
 
prop-noun-lex := noun-lex &
  [ SYNSEM.LKEYS.KEYREL named-relation ].
 
; 02-08-2009 gcs added 'overt-pronoun'
; 02-11-2009 gcs moved common predication for pronouns here
overt-pronoun := no-spr-noun-lex &
  [ SYNSEM.LKEYS.KEYREL.PRED "pron_rel" ].
              
non-demonst-pronoun-lex := overt-pronoun &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ SPECI +,
                                   COG-ST activ-or-more ] ].
   
animate-pronoun-lex := non-demonst-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEND masc-or-fem ].
 
m1sg-pronoun-lex := animate-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ PERS 1,
                                       NUM sg,
                                       GEND masc ] ].
 
f1sg-pronoun-lex := animate-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ PERS 1,
                                       NUM sg,
                                       GEND fem ] ].
 
2sg-pronoun-lex := animate-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS 2 ].
 
3-pronoun-lex := animate-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS 3 ].
 
1pl-pronoun-lex := animate-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ PERS 1,
                                       NUM pl ] ].
 
ia-3-pronoun-lex := non-demonst-pronoun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ PERS 3,
                                       GEND neut ] ].
 
; 02-19-2009 gcs added 'demonst-pronoun-lex' placeholder
; 03-07-2009 gcs no longer a placeholder
demonst-pronoun-lex := overt-pronoun &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ SPECI -,
                                   COG-ST activ+fam,
                                   PNG [ PERS 3,
                                         GEND neut ] ] ].
                                        
;;;--------------------------------------------------------------------------
;;; Adjectives
;;;
;;; 02-05-2009 gcs added adjective type 'adjective-lex'
;;; 02-12-2009 gcs added 'number-name-relation'
;;;--------------------------------------------------------------------------
 
attr-adjective-lex := basic-adjective-lex & intersective-mod-lex & norm-ltop-lex-item &
    [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD -,
                                    MOD < [ LOCAL.CAT [ HEAD noun,
                                                        VAL.SPR cons ] ] > ],
                             VAL [ SPR < >,
                                   SUBJ < >,
                                   COMPS < >,
                                   SPEC < > ],
                             POSTHEAD + ],
                       CONT.HOOK [ INDEX #ix,
                                   XARG #arg ] ],
               LKEYS.KEYREL [ ARG0 #ix,
                              ARG1 #arg ] ] ].
 
;;; 20111216 todo
ordinal-lex := attr-adjective-lex.
 
;;; 20111216 todo
honorific-lex := attr-adjective-lex.
                          
;;; 20111216 todo
superlative-lex := attr-adjective-lex.
 
pred-adj-lex := local-change-only-lex-rule &
  [ SYNSEM.LOCAL [ CAT [ HEAD adj & [ PRD +,
                                      MOD < > ],
                         VAL [ SPR < >,
                               SUBJ < [ OPT +, 
                                        LOCAL [ CAT [ HEAD noun,
                                                      VAL.SPR < > ],
                                                CONT.HOOK.INDEX #ind ] ] >,
                               COMPS < >,
                               SPEC < > ],
                         POSTHEAD #ph ],
                   CONT.HOOK #hk ],
    DTR.SYNSEM [ LOCAL [ CAT [ HEAD adj &
                                    [ MOD < [ LOCAL.CONT.HOOK.INDEX #ind ] > ],
                               VAL [ SPR < >,
                                     SUBJ < >,
                                     COMPS < >,
                                     SPEC < > ],
                               POSTHEAD #ph ],
                         CONT.HOOK #hk ] ] ].
                
;;;--------------------------------------------------------------------------
;;; Adverbs
;;;
;;; 02-05-2009 gcs added adverb type 'adverb-lex'
;;;--------------------------------------------------------------------------
                
adverb-lex := basic-adverb-lex & intersective-mod-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
                                                VAL.COMPS < > ] ]>,
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < >,
                             SPEC < > ] ] ].
                  
;;;--------------------------------------------------------------------------
;;; Verbs
;;; 02-12-2009 gcs added 'ditransitive-verb-lex' and 'no-drop-dt-verb-lex'
;;;--------------------------------------------------------------------------
 
; verb-lex is HC-LIGHT - to allow us to pick out
; 
;     lexical Vs for V-level attachment of negative adverbs.
 
verb-lex := lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD verb,
                       HC-LIGHT - ] ].
 
main-verb-init-lex := verb-lex & basic-verb-lex &
  [ SYNSEM.LOCAL [ CAT [ HEAD [FORM mv-form,
			       AUX -,
			       NEG - ],
                         VAL [ SPR < >,
                               SPEC < >,
                               SUBJ < #subj > ] ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT.VAL [ SPR < >,
                                     COMPS < > ],
                           CONT.HOOK.INDEX #xarg ] ] ].
 
main-verb-lex := main-verb-init-lex &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ SVC - ] ] ] ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item &
    [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
      ARG-ST.FIRST.LOCAL.CAT.HEAD noun ].
 
transitive-verb-lex := main-verb-lex & transitive-lex-item &
    [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
      ARG-ST < [ LOCAL.CAT.HEAD noun ], 
               #comps & [ LOCAL.CAT [ HEAD +nd,
                                      VAL [ SPR < >,
                                            COMPS < > ] ] ] > ].
                            
ditransitive-verb-lex := main-verb-lex & ditransitive-lex-item &
    [ SYNSEM.LOCAL.CAT.VAL.COMPS < #c1, #c2 >,
      ARG-ST < [ LOCAL.CAT.HEAD noun ],
               #c1 & [ LOCAL.CAT [ HEAD noun,
                                   VAL [ SPR < >,
                                         COMPS < > ] ] ] ,
               #c2 & [ LOCAL.CAT [ HEAD +np,
                                   VAL [ SPR < >,
                                         COMPS < > ] ] ] > ].
                                         
emb-clause-verb-lex := main-verb-lex & clausal-second-arg-trans-lex-item &
    [ SYNSEM.LOCAL.CAT.VAL.COMPS < #claus >,
      ARG-ST < [ LOCAL.CAT.HEAD noun ], 
               #claus & [ LOCAL [ CAT [ HEAD comp,
                                        VAL [ SPR < >,
                                              COMPS < > ] ],
                                  CONT.HOOK.INDEX.SF prop-or-ques ] ] > ].
                                             
i-verb-lex := intransitive-verb-lex.
 
drop-t-verb-lex := transitive-verb-lex & [ ARG-ST < [], [ OPT-CS type-id ] > ].
 
no-drop-t-verb-lex := transitive-verb-lex & [ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT -] > ].
 
no-drop-dt-verb-lex := ditransitive-verb-lex & [ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT -] , [OPT -] > ].
 
drop-io-dt-verb-lex := ditransitive-verb-lex & [ SYNSEM.LOCAL.CAT.VAL.COMPS < [OPT -] , [] > ].

;;;verb types based on all possible combinations of TYPE features
mot-intent-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP motion,
								     STATIVE -,
								     INTENTION + ] ].

mot-no-intent-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP motion,
									STATIVE -,
									INTENTION - ] ].

dir-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP direction,
							      STATIVE -,
							      INTENTION + ] ].

deic-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP deictic,
							       STATIVE -,
							       INTENTION + ] ].

posture-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP posture,
								  STATIVE -,
								  INTENTION + ] ].

stative-intent-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP none,
									 STATIVE +,
									 INTENTION + ] ].

stative-no-intent-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP none,
									    STATIVE +,
									    INTENTION - ] ].

no-stat-intent-verb-lex := main-verb-lex & [ SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP none,
									 STATIVE -,
									 INTENTION + ] ].

no-stat-no-intent-verb-lex := main-verb-lex & [SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP none,
									   STATIVE -,
									   INTENTION - ] ].

;;;Final verb types to be used in lexicon based on transitivity and TYPE feature combinations.
i-mot-intent-verb-lex := i-verb-lex & mot-intent-verb-lex.

drop-t-mot-intent-verb-lex := drop-t-verb-lex & mot-intent-verb-lex.

no-drop-t-mot-intent-verb-lex := no-drop-t-verb-lex & mot-intent-verb-lex.

drop-dt-mot-intent-verb-lex := drop-io-dt-verb-lex & mot-intent-verb-lex.

no-drop-dt-mot-intent-verb-lex := no-drop-dt-verb-lex & mot-intent-verb-lex.

i-mot-no-int-verb-lex := i-verb-lex & mot-no-intent-verb-lex.

drop-t-mot-no-int-verb-lex := drop-t-verb-lex & mot-no-intent-verb-lex.

no-drop-t-mot-no-int-verb-lex := no-drop-t-verb-lex & mot-no-intent-verb-lex.

drop-dt-mot-no-int-verb-lex := drop-io-dt-verb-lex & mot-no-intent-verb-lex.

no-drop-dt-mot-no-int-verb-lex := no-drop-dt-verb-lex & mot-no-intent-verb-lex.

i-dir-verb-lex := i-verb-lex & dir-verb-lex.

drop-t-dir-verb-lex := drop-t-verb-lex & dir-verb-lex.

no-drop-t-dir-verb-lex := no-drop-t-verb-lex & dir-verb-lex.

drop-dt-dir-verb-lex := drop-io-dt-verb-lex & dir-verb-lex.

no-drop-dt-dir-verb-lex := no-drop-dt-verb-lex & dir-verb-lex.

i-deictic-verb-lex := i-verb-lex & deic-verb-lex.

drop-t-deictic-verb-lex := drop-t-verb-lex & deic-verb-lex.

no-drop-t-deictic-verb-lex := no-drop-t-verb-lex & deic-verb-lex.

drop-dt-deictic-verb-lex := drop-io-dt-verb-lex & deic-verb-lex.

no-drop-dt-deictic-verb-lex := no-drop-dt-verb-lex & deic-verb-lex.

i-posture-verb-lex := i-verb-lex & posture-verb-lex.

drop-t-posture-verb-lex := drop-t-verb-lex & posture-verb-lex.

no-drop-t-posture-verb-lex := no-drop-t-verb-lex & posture-verb-lex.

drop-dt-posture-verb-lex := drop-io-dt-verb-lex & posture-verb-lex.

no-drop-dt-posture-verb-lex := no-drop-dt-verb-lex & posture-verb-lex.

i-stat-int-verb-lex := i-verb-lex & stative-intent-verb-lex.

drop-t-stat-int-verb-lex := drop-t-verb-lex & stative-intent-verb-lex.

no-drop-t-stat-int-verb-lex := no-drop-t-verb-lex & stative-intent-verb-lex.

drop-dt-stat-int-verb-lex := drop-io-dt-verb-lex & stative-intent-verb-lex.

no-drop-dt-stat-int-verb-lex := no-drop-dt-verb-lex & stative-intent-verb-lex.

i-stat-no-int-verb-lex := i-verb-lex & stative-no-intent-verb-lex.

drop-t-stat-no-int-verb-lex := drop-t-verb-lex & stative-no-intent-verb-lex.

no-drop-t-stat-no-int-verb-lex := no-drop-t-verb-lex & stative-no-intent-verb-lex.

drop-dt-stat-no-int-verb-lex := drop-io-dt-verb-lex & stative-no-intent-verb-lex.

no-drop-dt-stat-no-int-verb-lex := no-drop-dt-verb-lex & stative-no-intent-verb-lex.

i-no-stat-int-verb-lex := i-verb-lex & no-stat-intent-verb-lex.

drop-t-no-stat-int-verb-lex := drop-t-verb-lex & no-stat-intent-verb-lex.

no-drop-t-no-stat-int-verb-lex := no-drop-t-verb-lex & no-stat-intent-verb-lex.

drop-dt-no-stat-int-verb-lex := drop-io-dt-verb-lex & no-stat-intent-verb-lex.

no-drop-dt-no-stat-int-verb-lex := no-drop-dt-verb-lex & no-stat-intent-verb-lex.

i-no-stat-no-int-verb-lex := i-verb-lex & no-stat-no-intent-verb-lex.

drop-t-no-stat-no-int-verb-lex := drop-t-verb-lex & no-stat-no-intent-verb-lex.

no-drop-t-no-stat-no-int-verb-lex := no-drop-t-verb-lex & no-stat-no-intent-verb-lex.

drop-dt-no-stat-no-int-verb-lex := drop-io-dt-verb-lex & no-stat-no-intent-verb-lex.

no-drop-dt-no-stat-no-int-verb-lex := no-drop-dt-verb-lex & no-stat-no-intent-verb-lex.

;;;;;;;;;;;;;;;;;;;;;;;

emb-q-verb-lex := emb-clause-verb-lex & [ ARG-ST <   [], [ LOCAL [ CAT.MC -,
                                                                  CONT.HOOK.INDEX.SF ques ] ] > ].
 
emb-d-verb-lex := emb-clause-verb-lex & [ ARG-ST <   [], [ LOCAL.CONT.HOOK.INDEX.SF prop ] > ].
 
locative-verb-lex := main-verb-lex & trans-first-arg-raising-lex-item-1 &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
                             COMPS < #comps & [OPT -] >,
                             SPR < >,
                             SPEC < > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CONT.HOOK.INDEX #xarg,
                       CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ] ] ],
             #comps &
             [ LOCAL.CAT [ VAL [ COMPS < > ],
                           HEAD adp ] ] > ].
                            
negative-copula-lex := verb-lex & norm-ltop-lex-item & basic-two-arg &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ FORM mv-form ],
                           VAL [ SUBJ < #subj >,
                                 COMPS < #comps >,
                                 SPR < >,
                                 SPEC < > ] ],
                     CONT [ HCONS <! qeq & [ HARG #harg,
                                             LARG #larg ] !>,
                            HOOK.INDEX #this,
                            RELS <! relation , arg12-ev-relation & [ PRED "_be_v_id_rel", 
                                                            LBL #larg,
                                                            ARG0 #this,
                                                            ARG1 #xarg,
                                                            ARG2 #yarg ] !> ] ],
             LKEYS.KEYREL event-relation & [ ARG1 #harg ] ],
    ARG-ST < #subj &
             [ LOCAL [ CONT.HOOK.INDEX #xarg,
                       CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ] ] ],
             #comps &
             [ LOCAL [ CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ],
                       CONT.HOOK [ INDEX #yarg,
                                   XARG #xarg ] ] ] > ].
                            
                            
 causative-verb-lex := main-verb-lex & ditransitive-lex-item &
    [ SYNSEM.LOCAL.CAT.VAL.COMPS < #c1 & [OPT -], #c2 & [OPT -] >,
      ARG-ST < [ LOCAL.CAT.HEAD noun ],
               #c2 & [ LOCAL.CAT [ HEAD noun,
                                   VAL [ SPR < >,
                                         COMPS < > ] ] ] ,
               #c1 & [ LOCAL.CAT [ HEAD noun,
                                   VAL [ SPR < >,
                                         COMPS < > ] ] ] > ].
 
 
;;;--------------------------------------------------------------------------
;;; Adpositions
;;;--------------------------------------------------------------------------
 
case-marker-p-lex := basic-one-arg & raise-sem-lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD adp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comps >,
                             SPEC < > ] ],
    ARG-ST < #comps &
             [ LOCAL.CAT [ HEAD noun,
                           VAL.SPR < > ] ] > ].
                            
prep-lex := basic-int-mod-adposition-lex & transitive-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +nv,
                                                    VAL.SPR < > ] ] >,
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < #comps >,
                                 SPEC < > ] ],
                     CONT.HOOK.XARG #xa ],
             LKEYS.KEYREL.ARG1 #xa ],
    ARG-ST < [ ],
             #comps & [ OPT -,
               LOCAL.CAT [ HEAD noun,
                           VAL.SPR < > ] ] > ].
 
;;;--------------------------------------------------------------------------
;;; Auxiliaries
;;;--------------------------------------------------------------------------
 
subj-raise-aux := verb-lex & trans-first-arg-raising-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
                             COMPS < #comps >,
                             SPR < >,
                             SPEC < > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CONT.HOOK.INDEX #xarg,
                       CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ] ] ],
             #comps &
             [ LOCAL.CAT [ VAL [ SUBJ < [  ] >,
                                 COMPS < > ],
                           HEAD +vj ] ] > ].
 
subj-raise-aux-with-pred := subj-raise-aux & norm-sem-lex-item & trans-first-arg-raising-lex-item-1 &
  [ ARG-ST < [  ], [  ] > ].
 
; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.  Be sure to put in a comment.
 
subj-raise-aux-no-pred := subj-raise-aux & raise-sem-lex-item &
   [SYNSEM.LOCAL.CAT.HEAD.AUX + ].
 
imminent-aux-lex := subj-raise-aux-no-pred &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ FORM pre-aux ],
                         VAL.COMPS < [ OPT -,
                                       LOCAL [ CAT.HEAD.FORM mv-or-pre-aux,
                                               CONT.HOOK.INDEX.E.ASPECT #asp ] ] > ],
                   CONT.HOOK.INDEX.E.ASPECT #asp ] ].
 
tam1-aux-lex := subj-raise-aux-no-pred &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ FORM pre-aux,
                                LEFTCOMP - ],
                         VAL.COMPS < [ OPT -,
                                       LOCAL [ CAT.HEAD.FORM mv-or-pre-aux,
                                               CONT.HOOK.INDEX.E.ASPECT #asp ] ] > ],
                   CONT.HOOK.INDEX.E.ASPECT #asp ] ].
  
tam2-aux-lex := subj-raise-aux-no-pred &
  [ SYNSEM.LOCAL [ CAT [ HEAD [ FORM post-aux,
                                LEFTCOMP + ],
                         VAL.COMPS < [ OPT -,
                                       LOCAL [ CAT.HEAD.FORM any-form,
                                               CONT.HOOK.INDEX.E.ASPECT #asp ] ] > ],
                   CONT.HOOK.INDEX.E.ASPECT #asp ] ].
                    
epistemic-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT [ HEAD.FORM pre-aux,
                       VAL.COMPS < [ OPT -,
                                     LOCAL.CAT.HEAD.FORM mv-form ] > ] ].

;Adding negation to behave like a predicating auxiliary verb rather than a particle
neg-aux-lex := subj-raise-aux-with-pred &
    [ SYNSEM.LOCAL.CAT [ HEAD [FORM pre-aux, NEG + ],
			 VAL.COMPS < [ OPT -,
				       LOCAL.CAT.HEAD.FORM mv-form ] > ] ].

pot-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT [ HEAD [ FORM sealed,
                              LEFTCOMP + ],
                       VAL.COMPS < [ OPT -,
                                     LOCAL.CAT.HEAD.FORM any-form ] > ] ].
 
;;;--------------------------------------------------------------------------
;;; Demonstrative determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.
;;;
;;; 02-05-2009 gcs added determiner-lex
;;;--------------------------------------------------------------------------
 
demonstrative_a_rel := predsort.
proximal+dem_a_rel := demonstrative_a_rel. ; close to speaker
distal+dem_a_rel := demonstrative_a_rel.   ; away from speaker
mid+dem_a_rel := distal+dem_a_rel.         ; away, but not very far away
far+dem_a_rel := distal+dem_a_rel.         ; very far away
                                                              
#|
base-determiner-lex := norm-hook-lex-item & basic-zero-arg &
    [ SYNSEM [ LOCAL [ CAT [ HEAD det,
                             VAL [ SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,                                                               
                                                                LTOP #larg ],
                                   SPR < >,
                                   SUBJ < > ] ],
                       CONT [ RELS <! #qr !>,
                              HCONS <! qeq & [ HARG #harg,
                                                LARG #larg ] !> ] ],
               LKEYS [ KEYREL #qr & [ ARG0 #ind,
                      PRED "exist_q_rel",
                                      RSTR #harg ] ] ] ].
|#
                       
base-determiner-lex := norm-hook-lex-item & basic-zero-arg &
    [ SYNSEM [ LOCAL [ CAT [ HEAD det,
                             VAL [ SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,                                                               
                                                                LTOP #larg ],
                                   SPR < >,
                                   SUBJ < > ] ],
                       CONT [ HCONS <! qeq & [ HARG #harg,
                                                LARG #larg ] !>,
                              RELS.LIST.FIRST.PRED "exist_q_rel" ] ],
               LKEYS [ KEYREL quant-relation & [ ARG0 #ind,
                                                 RSTR #harg ] ] ] ].
 
demonst-determiner-lex := base-determiner-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.LEFTCOMP +,
                           VAL [ COMPS < [ LOCAL [ CAT.HEAD numcl & [ CLASSIF #cls ],
                                                   CONT.HOOK [ XARG #ind, 
                                                               LTOP #larg ] ] ] >,
                                 SPEC.FIRST.LOCAL [ CAT.HEAD.CLASSIF #cls,
                                                    CONT.HOOK [ INDEX #ind &
                                                                      [ COG-ST activ+fam,
                                                                        PNG.GEND neut],
                                                                LTOP #larg ] ] ] ],
                     CONT.RELS <! [ ] , #akr !> ],
             LKEYS.ALTKEYREL #akr & arg1-ev-relation & [ LBL #larg,
                                                         ARG1 #ind ] ] ].
 
; 02-14-2009 gcs
; we interrupt your regularly scheduled determiners to bring you a special
; type for (bare or numbered) numerical classifiers selected by a demonstrative:
 
demonst-numcl-lex := raise-sem-lex-item &
    [ SYNSEM.LOCAL [ CAT [ HEAD numcl & [ MOD < > ],
                           VAL [ COMPS < [ OPT +, LOCAL [ CAT.HEAD num,
                                                          CONT.HOOK [ XARG #xarg, 
                                                                      LTOP #larg ] ] ] >,
                                 SPEC < >,
                                 SPR < >,
                                 SUBJ < > ] ],
                     CONT.HOOK [ XARG #xarg, LTOP #larg ] ] ].
                      
sg-demonst-numcl-lex := demonst-numcl-lex &                    
    [ STEM.FIRST #cls,
      SYNSEM.LOCAL.CAT [ HEAD.CLASSIF #cls,
                         VAL.COMPS < [ LOCAL.CONT.HOOK.XARG.PNG.NUM sg ] > ] ].
 
pl-demonst-numcl-lex := demonst-numcl-lex &
    [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG.PNG.NUM pl ] > ].
 
numcl-lex := base-determiner-lex &
    [ STEM.FIRST #cls,
      SYNSEM.LOCAL.CAT [ HEAD.LEFTCOMP #lc,
                         VAL [ COMPS < [ OPT -,
                                         LOCAL [ CAT.HEAD num & [ LEFTCOMP #lc ],
                                                 CONT.HOOK [ LTOP #larg,
                                                             XARG #ind ] ] ] >,
                               SPEC.FIRST.LOCAL [ CAT.HEAD.CLASSIF #cls,
                                                  CONT.HOOK [ LTOP #larg,
                                                              INDEX #ind ] ] ] ] ].
                                                             
number-name-relation := carg-relation & arg1-ev-relation &
    [ PRED "card_rel" ].
 
base-number-lex := single-rel-lex-item & norm-ltop-lex-item & no-hcons-lex-item &
    [ SYNSEM [ LOCAL [ CAT [ HEAD num & [ MOD < > ],
                             VAL [ SPR < >,
                                   SUBJ < >,
                                   COMPS < > ] ],
                       CONT.HOOK [ LTOP #larg, XARG #xar ] ],
               LKEYS.KEYREL number-name-relation & [ LBL #larg, ARG1 #xar ] ] ].
 
; digits 0-9 except 1
; (digit 1 inherits from base-number-lex which is underspecified for LEFTCOMP; 
; thus it can appear to the left or right of the classifier)
number-lex := base-number-lex & [ SYNSEM.LOCAL.CAT.HEAD.LEFTCOMP + ].
 
;;;--------------------------------------------------------------------------
;;; Complementizers and question particles
;;; We treat question particles as complementizers.
;;; Here is the lexical type for complementizers.
;;;--------------------------------------------------------------------------
 
comp-base-lex-item := raise-sem-lex-item & basic-one-arg &
  [ SYNSEM.LOCAL.CAT [ HEAD comp & [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             SPEC < >,
                             COMPS < #comp > ] ],
    ARG-ST < #comp &
             [ LOCAL.CAT [ MC +,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ].
                                  
complementizer-lex-item := comp-base-lex-item & [ SYNSEM.LOCAL.CAT.MC - ].
 
ques-complementizer-lex := complementizer-lex-item &
    [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                     CAT.HEAD.LEFTCOMP - ],
      ARG-ST < [ LOCAL.CAT [ HEAD comp ] ] > ].
 
prop-complementizer-lex := complementizer-lex-item &
    [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF prop,
                     CAT.HEAD.LEFTCOMP - ],
      ARG-ST < [ LOCAL.CAT [ HEAD +vj ] ] > ].
 
qpart-lex := comp-base-lex-item &
  [ SYNSEM.LOCAL [ CAT [ HEAD.LEFTCOMP +, MC + ],
                   CONT.HOOK.INDEX.SF ques ],
    ARG-ST < [ LOCAL.CAT [ HEAD +vj ] ] > ].
 
 
;;;--------------------------------------------------------------------------
;;; Negators
;;; Type for negative adverbs.
;;;--------------------------------------------------------------------------
 
neg-adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < > ],
                       POSTHEAD -,
                       HEAD.MOD < [ LOCAL.CAT.HEAD +vj,
                                    LIGHT + ] > ] ].
 
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Phrasal types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2
 
basic-head-comp-phrase :+ [ SYNSEM.LOCAL.CAT.MC #mc,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].
 
basic-head-mod-phrase-simple :+ [ SYNSEM.LOCAL.CAT.MC #mc,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].
 
subj-head-phrase := decl-head-subj-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].
   
;;;;;;Phrase Structure Rules for Directional SVCs

svc-super-phrase := binary-phrase & phrasal &
   [ SYNSEM.LOCAL [COORD -,
		   COORD-REL #crel,
		   CAT [HEAD [MOD #mod,
			      KEYS #keys,
			      FORM #form,
			      PRD #prd,
			      CLASSIF #classif,
			      TYPE #type,
			      AUX -,
			      SVC +,
			      NEG - ],
			VAL [SUBJ < [LOCAL [CAT [HEAD noun,
						 VAL [SPR < >, COMPS < > ] ],
					    CONT.HOOK.INDEX #xarg] ] >,
			     COMPS < >,
			     SPR #spr,
			     SPEC #spec ] ],
		   CONT.HOOK [XARG #xarg,
			      INDEX #index3 ] ],
    ARGS < [SYNSEM.LOCAL [COORD -,
			  COORD-REL #crel,
			  CAT [HEAD verb, HEAD [MOD #mod,
						KEYS #keys,
						FORM #form,
						PRD #prd,
						CLASSIF #classif,
						TYPE #type,
						AUX -,
						NEG - ],
			       VAL [SUBJ <unexpressed>,
				    COMPS <>,
				    SPR #spr,
				    SPEC #spec ] ],
			  CONT.HOOK [XARG #xarg,
				     INDEX #index1,
				     LTOP #ltop] ] ],
	   [SYNSEM.LOCAL [COORD -,
			  CAT [HEAD verb,
			       HEAD [AUX -,
				     NEG -],
			       VAL [SUBJ <unexpressed>,
				    COMPS <>] ],
			  CONT.HOOK [XARG #xarg,
				     INDEX #index2,
				     LTOP #ltop ] ] ] >,
     C-CONT [HOOK [XARG #xarg, INDEX #index3, LTOP #ltop],
	     RELS <! [ARG0 #index3,
		      ARG1 #index1,
		      ARG2 #index2,
		      LBL #ltop ] !> ] ].

;Semantic Phrase Structure Rules
direction-sem-super-phrase := svc-super-phrase &
   [ARGS < [SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP motion-or-direction],
	   [SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP direction] >,
    C-CONT [RELS <! [PRED "path_rel"]  !> ] ].

result-sem-super-phrase := svc-super-phrase &
   [C-CONT [RELS <! [PRED "cause_rel"] !> ]].

first-dir-deic-svc-super-phrase := svc-super-phrase  &
   [ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVTYPE dir-deic ],
	   [SYNSEM.LOCAL.CAT.HEAD.TYPE [STATIVE -, MDDP not-deictic] ]  > ].

purpose-sem-super-phrase := first-dir-deic-svc-super-phrase &
   [C-CONT [RELS <! [PRED "purpose_rel"] !> ] ].

simultaneous-sem-super-phrase := first-dir-deic-svc-super-phrase &
   [C-CONT [RELS <! [PRED "while_rel"] !> ] ].

;VP-Content Rules
first-svc-super-phrase := svc-super-phrase &
   [ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVC + ], [SYNSEM.LOCAL.CAT.HEAD.SVC - ] > ].
   
second-svc-super-phrase := svc-super-phrase &
   [ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVC - ], [SYNSEM.LOCAL.CAT.HEAD.SVC + ] > ].

both-svc-super-phrase := svc-super-phrase &
   [ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVC + ], [SYNSEM.LOCAL.CAT.HEAD.SVC + ] >].

no-svc-super-phrase := svc-super-phrase &
   [ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVC - ], [SYNSEM.LOCAL.CAT.HEAD.SVC - ] >].

;Rules to form Long Directional SVCs
short-directional-svc-phrase := no-svc-super-phrase & direction-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE directional].

long-directional-svc-phrase := second-svc-super-phrase & direction-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE directional,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP motion-or-direction],
	   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE directional ]>].

long-dir-deic-svc-phrase := second-svc-super-phrase & direction-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE dir-deic,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP motion-or-direction],
	   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE dir-deic ] > ].

;Phrase structure rule to build purpose SVC with dir-deic as VP1
first-dir-deic-purpose-svc-phrase := first-svc-super-phrase &
				     purpose-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE deic-purpose,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVTYPE dir-deic],
	   [SYNSEM.LOCAL.CAT.HEAD.TYPE.INTENTION + ] > ].

;Phrase structure rule to build posture/simultaneous SVC with dir-deic as VP1
first-dir-deic-sim-svc-phrase := first-svc-super-phrase &
				 simultaneous-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE simultaneous].

;Phrase structure rule to build resultative SVC with Directional SVC as VP1
first-directional-resultative-svc-phrase := result-sem-super-phrase &
					    first-svc-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE resultative,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVTYPE directional],
	   [SYNSEM.LOCAL.CAT.HEAD.TYPE [STATIVE +, MDDP none] ]  > ].

;Phrase structure rule to build resultative SVC with Simultaneous SVC as VP1
first-simultaneous-resultative-svc-phrase := result-sem-super-phrase &
					     first-svc-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE resultative,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVTYPE simultaneous],
	   [SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP none ]  > ].

;Phrase Structure Rules for where VP1 is dir-deic SVC and VP2 is open-purpose SVC
;This can have a purpose or simultaneous reading.
dir-deic-open-purpose-super-svc-phrase := both-svc-super-phrase &
   [ ARGS < [SYNSEM.LOCAL.CAT.HEAD.SVTYPE dir-deic],
	    [SYNSEM.LOCAL.CAT.HEAD.SVTYPE open-purpose] > ].

dir-deic-open-purpose-purp-svc-phrase := dir-deic-open-purpose-super-svc-phrase &
					 purpose-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE deic-purpose].

dir-deic-open-purpose-sim-svc-phrase := dir-deic-open-purpose-super-svc-phrase &
					simultaneous-sem-super-phrase &
   [SYNSEM.LOCAL.CAT.HEAD.SVTYPE simultaneous].
   
; Rules for building NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.
 
; 02-13-2009 gcs Make sure selected determiner has its COMPS fulfilled
head-spec-phrase := basic-head-spec-phrase & head-initial &
  [ NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.VAL.COMPS olist,
                          OPT - ] ].

; Bare NP phrase.
 
bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].
   
; Head-Complement and Complement-Head
 
; 02-13-2009 gcs
; was [HEAD +nvjrpdmo] which is wrong because we need H-C for complementizer /waa/ 'that'
; could switch to +nvjrpcmo since we never need H-C for determiners
 
head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT [  MC #mc ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.LEFTCOMP -, MC #mc ] ].
     
comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC #spec,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.LEFTCOMP +,
                                VAL.SPEC #spec ] ].
 
cd-comp-head-phrase := comp-head-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD +cd ].
                                 
v-comp-head-phrase := comp-head-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM post-aux ].
     
d-comp-head-phrase := comp-head-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM sealed ].
 
; This grammar includes head-modifier rules.  To keep
; out extraneous parses, constrain the value of MOD on
; various subtypes of head.  This may need to be loosened later.
; This constraint says that only adverbs, adjectives,
; and adpositions can be modifiers:
 
+nvcdmo :+ [ MOD < > ].
 
;;;--------------------------------------------------------------------------
;;; Coordination Strategy 1
;;;--------------------------------------------------------------------------
 
n1-top-coord-rule := basic-n-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
n1-mid-coord-rule := basic-n-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
n1-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
;;; Coordination Strategy 1
 
np1-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
np1-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
np1-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
;;; Coordination Strategy 1
 
vp-coord-phrase :+ [ LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM mv-form,
                     RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM mv-form ].
 
vp1-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
vp1-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
vp1-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1,
    NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM mv-form ].
 
;;; Coordination Strategy 1
 
s1-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
s1-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
s1-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-1 ].
 
;;;--------------------------------------------------------------------------
;;; Coordination Strategy 2
;;;--------------------------------------------------------------------------
 
vp2-top-coord-rule := basic-vp-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT coord-mode-2 ].
 
vp2-bottom-coord-rule := unary-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT coord-mode-2,
                   COORD-REL.PRED "_and_c_rel" ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM mv-form ].
 
flags := *top* &
[ OPTIONAL luk,
  EQUAL list,
  SUBSUME list,
  TRIGGER string ].
 
mrs_transfer_rule := *top* &
[ FILTER mrs,
  CONTEXT mrs,
  INPUT mrs,
  OUTPUT mrs,
  FLAGS flags ].
 
generator_rule := mrs_transfer_rule &
[ INPUT.RELS <! !> ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;Lexical Rules for SVCs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Copy up constraints that are not changed by svc lex rule
svc-no-change-lex-rule := same-non-local-lex-rule & same-modified-lex-rule &
			  same-light-lex-rule & same-agr-lex-rule & same-hc-light-lex-rule &
			  same-posthead-lex-rule & same-mc-lex-rule &
   [ SYNSEM [ LOCAL.CAT [ HEAD [ MOD #mod,
				 KEYS #keys,
				 FORM #form,
				 PRD #prd,
				 CLASSIF #classif,
				 TYPE #type ],
			  VAL [ SUBJ #subj,
				SPR #spr,
				SPEC #spec ] ],
	      LKEYS #lkeys ],
     DTR.SYNSEM [ LOCAL.CAT [HEAD [ MOD #mod,
				    KEYS #keys,
				    FORM #form,
				    PRD #prd,
				    CLASSIF #classif,
				    TYPE #type ],
			     VAL [ SUBJ #subj,
				   SPR #spr,
				   SPEC #spec ] ],
		  LKEYS #lkeys ] ].


;Topmost rule in SVC hierarchy, take a verb and makes it [SVC +]

serial-verb-lex-rule := svc-no-change-lex-rule &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb, HEAD [LEFTCOMP -,
					  SVC +,
					  AUX -,
					  NEG - ] ] ],
    DTR.SYNSEM.LOCAL.CAT [ HEAD verb, HEAD [SVC -,
					    AUX -,
					    NEG - ] ] ].
;;;Argument Sharing Lexical Rules

;;When V1 is intransitive, the only possible type of arg share is shared-subject
shared-subject-intrans-svc-lex-rule := serial-verb-lex-rule &
   [ SYNSEM.LOCAL [CAT [HEAD.LEFTCOMP -,
			VAL [ SUBJ < #subj & [LOCAL [ CAT.HEAD noun,
						      CONT.HOOK.INDEX #xarg ] ] >,
			      COMPS < [OPT -,
				       LOCAL [CAT [HEAD verb, HEAD [AUX -, NEG - ],
						   VAL [ COMPS <>,
							 SUBJ <unexpressed> ] ],
					      CONT.HOOK [XARG #xarg,
							 LTOP #ltop,
							 INDEX #indexVP] ] ] > ] ],
		   CONT.HOOK.XARG #xarg ],
     DTR.SYNSEM.LOCAL [CAT.VAL [SUBJ < #subj >, COMPS < > ],
		       CONT.HOOK [XARG #xarg, LTOP #ltop, INDEX #index1] ],
     C-CONT [HOOK [XARG #xarg, LTOP #ltop, INDEX #index2 ],
	     RELS <! [ARG0 #index2,
		      ARG1 #index1,
		      ARG2 #indexVP,
		      LBL #ltop] !> ]].

;;When V2 is transitive,the SVC can be shared-subject, switch-function, or shared-subject-object

;Transitive V1 super lex rule
trans-v1-super-lex-rule := serial-verb-lex-rule &
[ SYNSEM.LOCAL [CAT.VAL [SUBJ < #subj & [LOCAL [CAT.HEAD noun, CONT.HOOK.INDEX #xarg] ] >,
			 COMPS < [LOCAL #loc, NON-LOCAL #nl],
				 [OPT -,
				  LOCAL [CAT [HEAD verb, HEAD [AUX -, NEG -] ],
					 CONT.HOOK [LTOP #ltop,
						    INDEX #indexV] ] ] > ],
		CONT.HOOK.XARG #xarg ],
  DTR.SYNSEM.LOCAL [CAT.VAL [SUBJ < #subj >, COMPS < [LOCAL #loc, NON-LOCAL #nl] > ],
		    CONT.HOOK [ XARG #xarg, INDEX #index1, LTOP #ltop ] ],
  C-CONT [ HOOK [XARG #xarg, INDEX #index2, LTOP #ltop],
	   RELS <! [ ARG0 #index2,
		     ARG1 #index1,
		     ARG2 #indexV,
		     LBL #ltop] !> ] ].
  
;Transitive V1 argument-sharing lex rules
shared-subject-trans-svc-lex-rule := trans-v1-super-lex-rule &
[ SYNSEM.LOCAL [CAT [VAL [ SUBJ < #subj & [LOCAL.CONT.HOOK.INDEX #xarg] >,
			   COMPS < #comps1,
				   #compsVP & [ LOCAL [CAT.VAL [ COMPS <>,
								 SUBJ <unexpressed> ],
						       CONT.HOOK.XARG #xarg ] ] > ] ] ],
  ARG-ST < #subj, #comps1, #compsVP > ].


switch-function-svc-lex-rule := trans-v1-super-lex-rule &
[ SYNSEM.LOCAL.CAT [ VAL [ COMPS < [LOCAL.CONT.HOOK.INDEX #index],
				   [LOCAL [CAT.VAL [COMPS <>,
						    SUBJ <unexpressed> ],
					   CONT.HOOK.XARG #index ] ] > ] ] ].

shared-subject-object-svc-lex-rule := trans-v1-super-lex-rule &
[ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #xarg] >,
			   COMPS <#comps1 & [LOCAL.CAT.HEAD noun],
				  [LOCAL [ CAT.VAL.COMPS < #comps1 > ,
					   CONT.HOOK.XARG #xarg ] ] > ] ] ].

;;;Semantic Lexical Rules

direction-sem-lex-rule := serial-verb-lex-rule &
[C-CONT.RELS <! [PRED "path_rel"] !> ].

purpose-sem-lex-rule := serial-verb-lex-rule &
[C-CONT.RELS <! [PRED "purpose_rel"] !> ].

result-sem-lex-rule := serial-verb-lex-rule &
[C-CONT.RELS <! [PRED "cause_rel"] !> ].

simultaneous-sem-lex-rule := serial-verb-lex-rule &
[C-CONT.RELS <! [PRED "while_rel"] !> ].

sequential-sem-lex-rule := serial-verb-lex-rule &
[C-CONT.RELS <! [PRED "then_rel"] !> ].

;Sequential and Open-Purpose SVCs

sequential-svc-lex-rule := shared-subject-object-svc-lex-rule &
			   sequential-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE sequential,
		       VAL.COMPS <[OPT -], [LOCAL.CAT.HEAD [ SVC -,
							     TYPE [MDDP not-deictic,
								   STATIVE - ] ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP not-deictic,
				     STATIVE - ] ].

open-purpose-svc-lex-rule := shared-subject-object-svc-lex-rule &
			     purpose-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE open-purpose,
		       VAL [ COMPS <[OPT -], [LOCAL.CAT.HEAD [ SVC -,
							       TYPE [MDDP not-deictic,
								     STATIVE -,
								     INTENTION + ] ] ] > ] ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE [MDDP not-deictic,
				     STATIVE - ] ].


;Direction-Deictic SVC
dir-deic-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
			       direction-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE dir-deic,
			VAL.COMPS <[OPT +], [LOCAL.CAT.HEAD [ SVC -,
							      TYPE.MDDP deictic ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP motion-or-direction ].

dir-deic-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
				 direction-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE dir-deic,
			VAL.COMPS <[LOCAL.CAT.HEAD [ SVC -,
						     TYPE.MDDP deictic ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP motion-or-direction ].

;Posture/Simultaneous SVCs
simultaneous-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
				   simultaneous-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE simultaneous,
			VAL.COMPS <#comps1, [LOCAL.CAT.HEAD [ SVC -,
							      TYPE [MDDP none,
								    STATIVE - ] ] ] > ],
     DTR.SYNSEM.LOCAL.CAT [HEAD.TYPE.MDDP motion-or-posture,
			   VAL.COMPS <#comps1> ] ].


simultaneous-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
				     simultaneous-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE simultaneous,
			VAL.COMPS < [LOCAL.CAT.HEAD [ SVC -,
						      TYPE [MDDP none,
							    STATIVE - ] ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP motion-or-posture ].


;Deictic Purpose SVCs
deic-purpose-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
				   purpose-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE deic-purpose,
			VAL.COMPS <#comps1, [LOCAL.CAT.HEAD [ SVC -,
							      TYPE [MDDP not-deictic,
								    STATIVE -,
								    INTENTION + ] ] ] > ],
     DTR.SYNSEM.LOCAL.CAT [HEAD.TYPE.MDDP deictic,
			   VAL.COMPS <#comps1> ] ].


deic-purpose-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
				     purpose-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE deic-purpose,
			VAL.COMPS <[LOCAL.CAT.HEAD [ SVC -,
						     TYPE [MDDP not-deictic,
							   STATIVE -,
							   INTENTION + ] ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP deictic ].

;Directional SVC (cannot also end in a deictic), simultaneous  SVC, or Shared-Subj-Obj
;as V2 of deictic-purpose.
deic-purpose-interact-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
					    purpose-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE deic-purpose,
			VAL.COMPS <#comps1, [LOCAL.CAT.HEAD [ SVC +,
							      SVTYPE deic-purp-vp2 ] ] > ],
     DTR.SYNSEM.LOCAL.CAT [HEAD.TYPE.MDDP deictic,
			   VAL.COMPS <#comps1> ] ].

deic-purpose-interact-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
					      purpose-sem-lex-rule &
   [ SYNSEM.LOCAL.CAT [ HEAD.SVTYPE deic-purpose,
			VAL.COMPS <[LOCAL.CAT.HEAD [ SVC +,
						     SVTYPE deic-purp-vp2 ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE.MDDP deictic ].

;Resultatives
no-dir-super-svc-lex-rule := result-sem-lex-rule &
   [ DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE [ MDDP none, STATIVE - ] ].

dir-super-svc-lex-rule := result-sem-lex-rule &
   [ DTR.SYNSEM.LOCAL.CAT.HEAD.TYPE [ MDDP motion-or-direction, STATIVE - ] ].

res-dir-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
			      dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <#comps1, [LOCAL.CAT.HEAD [ SVC -,
							     TYPE [ MDDP none,
								    STATIVE + ] ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <#comps1> ].

res-nodir-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
				no-dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <#comps1, [LOCAL.CAT.HEAD [ SVC -,
							     TYPE.MDDP not-deictic ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <#comps1> ].


res-dir-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
				dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <[LOCAL.CAT.HEAD [ SVC -,
						    TYPE [ MDDP none,
							   STATIVE + ] ] ] > ] ].

res-nodir-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
				  no-dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <[LOCAL.CAT.HEAD [ SVC -,
						    TYPE.MDDP not-deictic ] ] > ] ].


res-dir-switch-svc-lex-rule := switch-function-svc-lex-rule &
			       dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <[OPT -], [LOCAL.CAT.HEAD [ SVC -,
							     TYPE [ MDDP none,
								    STATIVE + ] ] ] > ] ].


res-nodir-switch-svc-lex-rule := switch-function-svc-lex-rule &
				 no-dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <[OPT -], [LOCAL.CAT.HEAD [ SVC -,
							     TYPE.MDDP not-deictic ] ] > ] ].

;Dir-deic or Simultaneous SVC as V2 of resultative.
;Allow for transitive, intransitive and switch-func.
;V1 cannot be motion or direction - must be MDDP none.

res-interact-trans-svc-lex-rule := shared-subject-trans-svc-lex-rule &
				   no-dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <#comps1, [LOCAL.CAT.HEAD [ SVC +,
							     SVTYPE dir-deic-or-simul ] ] > ],
     DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <#comps1> ].


res-interact-intrans-svc-lex-rule := shared-subject-intrans-svc-lex-rule &
				     no-dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <[LOCAL.CAT.HEAD [ SVC +,
						    SVTYPE dir-deic-or-simul ] ] > ] ].

res-interact-switch-svc-lex-rule := switch-function-svc-lex-rule &
				    no-dir-super-svc-lex-rule &
   [ SYNSEM.LOCAL.CAT [HEAD.SVTYPE resultative,
		       VAL.COMPS <[OPT -], [LOCAL.CAT.HEAD [ SVC +,
							     SVTYPE dir-deic-or-simul ] ] > ] ].
